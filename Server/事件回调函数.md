## 事件回调函数

`Swoole\Server`是事件驱动模式，所有的业务逻辑代码必须写在事件回调函数中。当特定的网络事件发生后，底层会主动回调指定的PHP函数。

事件执行顺序
----

* 所有事件回调均在`$server->start`后发生
* 服务器关闭程序终止时最后一次事件是`onShutdown`
* 服务器启动成功后，`onStart`/`onManagerStart`/`onWorkerStart`会在不同的进程内并发执行
* `onReceive`/`onConnect`/`onClose`在`Worker`进程中触发
* `Worker`/`Task`进程启动/结束时会分别调用一次`onWorkerStart`/`onWorkerStop`
* `onTask`事件仅在`task`进程中发生
* `onFinish`事件仅在`worker`进程中发生

> onStart/onManagerStart/onWorkerStart 3个事件的执行顺序是不确定的

异常捕获
----

* swoole不支持set_exception_handler函数
* 如果你的PHP代码有抛出异常逻辑，必须在事件回调函数顶层进行try/catch来捕获异常

```php
$serv->on('Receive', function() {
    try
    {
        //some code
    }
    catch(Exception $e)
    {
        //exception code
    }
}
```

## onStart

`Server`启动在主进程的主线程回调此函数，函数原型

```php
function onStart(swoole_server $server);
```

在此事件之前Swoole Server已进行了如下操作

* 已创建了manager进程
* 已创建了worker子进程
* 已监听所有TCP/UDP端口
* 已监听了定时器

接下来要执行

* 主Reactor开始接收事件，客户端可以connect到Server

__onStart回调中，仅允许echo、打印Log、修改进程名称。不得执行其他操作。onWorkerStart和onStart回调是在不同进程中并行执行的，不存在先后顺序__

可以在onStart回调中，将$serv->master_pid和$serv->manager_pid的值保存到一个文件中。这样可以编写脚本，向这两个PID发送信号来实现关闭和重启的操作

onStart事件在Master进程的主线程中被调用

> 在onStart中创建的**全局资源对象**不能在worker进程中被使用，因为发生onStart调用时，worker进程已经创建好了。

> 新创建的对象在主进程内，worker进程无法访问到此内存区域。

> 因此全局对象创建的代码需要放置在swoole_server_start之前。


## onShutdown

此事件在`Server`正常结束时发生，函数原型
```php
function onShutdown(swoole_server $server);
```

在此之前`Swoole\Server`已进行了如下操作

* 已关闭所有Reactor线程、HeartbeatCheck线程、UdpRecv线程
* 已关闭所有Worker进程、Task进程、User进程
* 已close所有TCP/UDP/UnixSocket监听端口
* 已关闭主Reactor

> 强制kill进程不会回调onShutdown，如kill -9

> 需要使用kill -15来发送SIGTREM信号到主进程才能按照正常的流程终止

> 在命令行中使用Ctrl+C中断程序会立即停止，底层不会回调onShutdown

## onWorkerStart

此事件在`Worker`进程/`Task`进程启动时发生。这里创建的对象可以在进程生命周期内使用。原型：

```php
function onWorkerStart(swoole_server $server, int $worker_id);
```

* 发生致命错误或者代码中主动调用`exit`时，`Worker`/`Task`进程会退出，管理进程会重新创建新的进程
* `onWorkerStart`/`onStart`是并发执行的，没有先后顺序
* 可以通过`$server->taskworker`属性来判断当前是`Worker`进程还是`Task`进程

下面的示例用于为`Worker`进程/`Task`进程重命名:
```php
$serv->on('WorkerStart', function ($serv, $worker_id){
    global $argv;
    if($worker_id >= $serv->setting['worker_num']) {
        swoole_set_process_name("php {$argv[0]} task worker");
    } else {
        swoole_set_process_name("php {$argv[0]} event worker");
    }
});
```

如果想使用`Reload`机制实现代码重载入，必须在`onWorkerStart`中`require`你的业务文件，而不是在文件头部。在`onWorkerStart`调用之前已包含的文件，不会重新载入代码。

> 可以将公用的、不易变的php文件放置到onWorkerStart之前。这样虽然不能重载入代码，但所有Worker是共享的，不需要额外的内存来保存这些数据。

> onWorkerStart之后的代码每个进程都需要在内存中保存一份

* $worker_id是一个从0-$worker_num之间的数字，表示这个Worker进程的ID
* $worker_id和进程PID没有任何关系，可使用posix_getpid函数获取PID

练手demo
------
demo文件:onWorderStartServer.php

执行结果:
![image](./pic/18.png)

```记录
1. 在终端执行结果可用看出task进程启动要优于worker进行，但从启动ID来看缺是tasker的ID大于workerID。因此可认为tasker跟worker启动是并行的
2. 从ID的角度来看，是先分配完workerID后再分配taskerID
```

## onWorkerStop

此事件在worker进程终止时发生。在此函数中可以回收worker进程申请的各类资源。原型：
```php
function onWorkerStop(swoole_server $server, int $worker_id);
```

* $worker_id是一个从0-$worker_num之间的数字，表示这个worker进程的ID
* $worker_id和进程PID没有任何关系
* 进程异常结束，如被强制kill、致命错误、core dump 时无法执行onWorkerStop回调函数

## onWorkerExit

仅在开启`reload_async`特性后有效。异步重启特性，会先创建新的Worker进程处理新请求，旧的Worker进程自行退出。原型:
```php
function onWorkerExit(swoole_server $server, int $worker_id);
```

* `Worker`进程未退出，`onWorkerExit`会持续触发
* `onWorkerExit`仅在Worker进程内触发，`Task`进程不执行`onWorkerExit`

旧的`Worker`进程，在退出时先会执行一次`onWorkerStop`事件回调，然后会在事件循环的每个周期结束时调用`onWorkerExit`通知`Worker`进程退出。

在`onWorkerExit`中尽可能地移除/关闭异步的Socket连接，最终底层检测到`Reactor`中事件监听的句柄数量为0时退出进程

## onConnect