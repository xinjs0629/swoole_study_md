# swoole_server::__construct

创建一个异步Server对象

````
$serv = new swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS,
    int $sock_type = SWOOLE_SOCK_TCP);
````

## 参数
* $host参数用来指定监听的ip地址，如127.0.0.1，或者外网地址，或者0.0.0.0监听全部地址  
    *  IPv4使用 127.0.0.1表示监听本机，0.0.0.0表示监听所有地址  
    * IPv6使用::1表示监听本机，:: (相当于0:0:0:0:0:0:0:0) 表示监听所有地址

* $port监听的端口，如9501  
    * 如果$sock_type为UnixSocket Stream/Dgram，此参数将被忽略
    * 监听小于1024端口需要root权限
    * 如果此端口被占用server->start时会失败

* $mode运行的模式
    * SWOOLE_PROCESS多进程模式（默认）
    * SWOOLE_BASE基本模式

* $sock_type指定Socket的类型，支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种

## 注意事项

* 底层有保护机制，一个PHP程序内只能创建启动一个Server实例
* 如果要实现多个Server实例的管理，父进程必须使用exec，不得使用fork

## demo练手（construct.php）

![image](./pic/3.png)

````
php脚本只是单纯将swoole实例化出来，并没有启动的情况下可以根据执行结果看出并没有占用对应实例化出来的端口，因此可以认为即使实例化出来没有开启一样不会有效果
````

# swoole_server->set

swoole_server->set函数用于设置swoole_server运行时的各项参数。服务器启动后通过$serv->setting来访问set函数设置的参数数组。  


````
//原型：
function swoole_server->set(array $setting);

//示例：
$serv->set(array(
    //通过此参数来调节poll线程的数量，以充分利用多核
    'reactor_num' => 2, 
    
    //设置启动的worker进程数量。swoole采用固定worker进程的模式
    //PHP代码中是全异步非阻塞，worker_num配置为CPU核数的1-4倍即可。如果是同步阻塞，worker_num配置为100或者更高，具体要看每次请求处理的耗时和操作系统负载状况。
    'worker_num' => 4, 
    
    //此参数将决定最多同时有多少个待accept的连接，swoole本身accept效率是很高的，基本上不会出现大量排队情况。
    'backlog' => 128,  
    
    //此参数表示worker进程在处理完n次请求后结束运行。manager会重新创建一个worker进程。此选项用来防止worker进程内存溢出
    //设置为0表示不自动重启。在Worker进程中需要保存连接信息的服务，需要设置为0.
    'max_request' => 50,
    
    //worker进程数据包分配模式:1平均分配，2按FD取模固定分配，3抢占式分配，默认为取模(dispatch=2)
    //抢占式分配，每次都是空闲的worker进程获得数据。很合适SOA/RPC类的内部服务框架
    //当选择为dispatch=3抢占模式时，worker进程内发生onConnect/onReceive/onClose/onTimer会将worker进程标记为忙，不再接受新的请求。reactor会将新请求投递给其他状态为闲的worker进程
      如果希望每个连接的数据分配给固定的worker进程，dispatch_mode需要设置为2
    'dispatch_mode' => 1,
    
    //此参数用来设置Server最大允许维持多少个tcp连接。超过此数量后，新进入的连接将被拒绝
    'max_con' => 1000, 
    
    //加入此参数后，执行php server.php将转入后台作为守护进程运行
    daemonize => 1, 
    
    //启用CPU亲和设置
    open_cpu_affinity => 1,
    
    //TCP_NoDelay启用
    open_tcp_nodelay => 1 ,
    
    //此参数设定一个秒数，当客户端连接连接到服务器时，在约定秒数内并不会触发accept，直到有数据发送，或者超时时才会触发。
    tcp_defer_accept => 5,
    
    //指定swoole错误日志文件。在swoole运行期发生的异常信息会记录到这个文件中。默认会打印到屏幕
    log_file => '/data/log/swoole.log',
    
    //buffer主要是用于检测数据是否完整，如果不完整swoole会继续等待新的数据到来。直到收到完整的一个请求，才会一次性发送给worker进程。这时onReceive会收到一个超过SW_BUFFER_SIZE，
    //小于$serv->setting['package_max_length']的数据。
    //目前仅提供了EOF检测、固定包头长度检测2种buffer模式。
    open_eof_check => true, //打开buffer
    package_eof => "\r\n\r\n", //设置EOF
    
    //每隔多少秒检测一次，单位秒，Swoole会轮询所有TCP连接，将超过心跳时间的连接关闭掉
    heartbeat_check_interval => 30,
    //TCP连接的最大闲置时间，单位s , 如果某fd最后一次发包距离现在的时间超过heartbeat_idle_time会把这个连接关闭。
    heartbeat_idle_time => 60,
    
    
));
````

**swoole_server->set只能在swoole_server->start前调用**


# swoole_server->on

注册Server的事件回调函数。

````
bool swoole_server->on(string $event, mixed $callback);
````

* 第1个参数是回调的名称, 大小写不敏感，具体内容参考回调函数列表，事件名称字符串不要加on
* 第2个函数是回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数。

**重复调用on方法时会覆盖上一次的设定**

## demo练手（on.php）

![image](./pic/4.png)
![image](./pic/5.png)

````
1.根据第一张图可以看到当进程启动后通过浏览器访问则触发连接（connect）与断开（close）的回调
2.因为demo代码中写了两个connect的方法，印证了'重复调用on方法时会覆盖上一次的设定'
3.图2证明了进程启动后9501端口的确被占用了
````

# swoole_server->addListener

Swoole提供了swoole_server::addListener来增加监听的端口。业务代码中可以通过调用swoole_server::connection_info来获取某个连接来自于哪个端口

````
//函数原型：
function swoole_server->addListener(string $host, int $port, $type = SWOOLE_SOCK_TCP);
````
* 监听1024以下的端口需要root权限
* 1.8.0版本增加了多端口监听的功能，监听成功后会返回Swoole\Server\Port对象
* 在此对象上可以设置另外的事件回调函数和运行参数
* 监听失败返回false，可调用getLastError方法获取错误码
* 主服务器是WebSocket或Http协议，新监听的TCP端口默认会继承主Server的协议设置。必须单独调用set方法设置新的协议才会启用新协议 查看详细说明

## swoole支持的Socket类型


* SWOOLE_TCP/SWOOLE_SOCK_TCP //tcp ipv4 socket
* SWOOLE_TCP6/SWOOLE_SOCK_TCP6 //tcp ipv6 socket
* SWOOLE_UDP/SWOOLE_SOCK_UDP //udp ipv4 socket
* SWOOLE_UDP6/SWOOLE_SOCK_UDP6 //udp ipv6 socket
* SWOOLE_UNIX_DGRAM //unix socket dgram
* SWOOLE_UNIX_STREAM //unix socket stream

# swoole_server->addProcess

添加一个用户自定义的工作进程。此函数通常用于创建一个特殊的工作进程，用于监控、上报或者其他特殊的任务

````
bool swoole_server->addProcess(swoole_process $process);
````

## 参数
* $process 为swoole_process对象，注意不需要执行start。在swoole_server启动时会自动创建进程，并执行指定的子进程函数
* 创建的子进程可以调用$server对象提供的各个方法，如connection_list/connection_info/stats
* 在worker/task进程中可以调用$process提供的方法与子进程进行通信
* 在用户自定义进程中可以调用$server->sendMessage与worker/task进程通信

## 返回值
* 返回值：添加成功返回true，失败返回false

## 注意事项

* 自定义进程会托管到Manager进程，如果发生致命错误，Manager进程会重新创建一个
* 自定义进程不受reload指令控制，reload时不会向用户进程发送任何信息
* 在shutdown关闭服务器时，会向自定义进程发送SIGTERM信号
* 自定义进程内不能使用swoole_server->task/taskwait接口

## 练手Demo （addProcess.php）

![image](./pic/6.png)
执行后的进程父子关系如上图

````
待续查询的疑问
1.父子关系为何是3层？
2.子进程处理的内容是否只while的内容
3.demo内容是否表示通过脚本创建了一个进程，该进程依赖于自身守护进程运行的进程作为父进程，而在新增的进程为衍生出4个子进程的父进程
````

# swoole_server->listen

监听一个新的Server端口，此方法是addlistener的别名。

````
bool swoole_server->listen(string $host, int $port, int $type);
````

# swoole_server->start

启动server，监听所有TCP/UDP端口，函数原型：

````
bool swoole_server->start()
````

* 启动成功后会创建worker_num+2个进程。Master进程+Manager进程+serv->worker_num个Worker进程。
* 启动失败会立即返回false
* 启动成功后将进入事件循环，等待客户端连接请求。start方法之后的代码不会执行
* 服务器关闭后，start函数返回true，并继续向下执行
* 设置了task_worker_num会增加相应数量的Task进程
* 函数列表中start之前的方法仅可在start调用前使用，在start之后的方法仅可在onWorkerStart、onReceive等事件回调函数中使用

## 主进程
主进程内有多个Reactor线程，基于epoll/kqueue进行网络事件轮询。收到数据后转发到worker进程去处理

## Manager进程
对所有worker进程进行管理，worker进程生命周期结束或者发生异常时自动回收，并创建新的worker进程

## worker进程

对收到的数据进行处理，包括协议解析和响应请求。

启动失败扩展内会抛出致命错误，请检查php error_log的相关信息。errno={number}是标准的Linux Errno，可参考相关文档。
如果开启了log_file设置，信息会打印到指定的Log文件中。

如果想要在开机启动时，自动运行你的Server，可以在/etc/rc.local文件中加入

## 常见的错误有
* bind端口失败,原因是其他进程已占用了此端口
* 未设置必选回调函数，启动失败
* php有代码致命错误，请检查php的错误信息php_err.log
* 执行ulimit -c unlimited，打开core dump，查看是否有段错误
* 关闭daemonize，关闭log，使错误信息可以打印到屏幕

## 练手Demo （start.php）
````
1.因为设置了守护进程模式打开，因此当手动执行代码时默认将执行模型变为守护进程，搜索进程是存在的
2.当脚本一执行时，log日志有设置的话则自动生成文件（及时没报错）
3.当再次运行脚本因为使用的端口一致会导致第二个脚本报错，报错信息提示网络地址已被使用
````

# swoole_server->reload

重启所有worker进程
````
bool swoole_server->reload(bool $only_reload_taskworkrer = false)
````

* $only_reload_taskworkrer 是否仅重启task进程